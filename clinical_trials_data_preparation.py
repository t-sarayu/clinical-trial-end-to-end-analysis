# -*- coding: utf-8 -*-
"""clinical_trials_data_preparation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1t0aAf8QHdAgwvusXMagv-Ryio7q8p6qU

# **Clinical Trial Data Analysis**

# Data organizing

**DATA INGESTION**
"""

import pandas as pd
import numpy as np

patients = pd.read_excel("/content/clinical_trial_raw.xlsx", sheet_name="patients")
lab = pd.read_excel("/content/clinical_trial_raw.xlsx", sheet_name="lab_results")
adverse_events = pd.read_excel("/content/clinical_trial_raw.xlsx", sheet_name="adverse_events")
trial_outcomes = pd.read_excel("/content/clinical_trial_raw.xlsx", sheet_name="trial_outcomes")

df = patients.merge(lab, on="patient_id", how="left") \
             .merge(adverse_events, on="patient_id", how="left") \
             .merge(trial_outcomes, on="patient_id", how="left")

df.to_csv("clinical_trials_merged.csv", index=False)

"""# Data Cleaning

Load CSV
"""

df = pd.read_csv("/content/clinical_trials_merged.csv")

"""**BASIC PROFILING**"""

import matplotlib.pyplot as plt

# Count missing values per column
missing_counts = df.isnull().sum()

# Keep only columns with missing values
missing_counts = missing_counts[missing_counts > 0]

# Bar chart
plt.figure(figsize=(10, 5))
missing_counts.plot(kind='bar')

plt.title('Missing Values per Column')
plt.xlabel('Columns')
plt.ylabel('Number of Missing Values')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

# --- STANDARDIZE COL NAMES (lowercase)
df.columns = [c.strip().lower() for c in df.columns]

df.info()

df.describe(include='all')

df.isnull().sum()

"""**1. DEMOGRAPHICS (patient_dim)**"""

demo_cols = ["patient_id","name","dob","gender","weight","height","smoking_status","enrollment_date","country","contact_number"]
demo = df[demo_cols].drop_duplicates(subset=["patient_id"]).copy()

"""1.1 Age"""

demo['dob']=pd.to_datetime(demo['dob'],errors='coerce')
today = pd.Timestamp.today().normalize()
demo['age'] = ((today - demo['dob']).dt.days // 365).astype('float')

demo['age'].fillna(demo['age'].median(), inplace=True)

"""1.2 BMI"""

demo['height_cm'] = pd.to_numeric(demo['height'], errors='coerce')
demo['weight_kg'] = pd.to_numeric(demo['weight'], errors='coerce')
demo['height_m'] = demo['height_cm'] / 100

demo['bmi'] = demo['weight_kg'] / (demo['height_m']**2)

demo['bmi'].replace([np.inf, -np.inf], np.nan, inplace=True)

demo['bmi'].fillna(demo['bmi'].median(), inplace=True)

"""1.3 Fill categorical"""

# --- STANDARDIZE GENDER ---
demo['gender_raw'] = demo['gender']
demo['gender'] = demo['gender'].astype(str).str.strip().str.lower()

gender_map = {
    'f': 'Female', 'female': 'Female',
    'm': 'Male', 'male': 'Male'
}
demo['gender'] = demo['gender'].map(gender_map).fillna('Unknown')

# --- STANDARDIZE SMOKING STATUS ---
demo['smoking_status_raw'] = demo['smoking_status']
demo['smoking_status'] = demo['smoking_status'].astype(str).str.strip().str.lower()

smoking_map = {
    'y':'Smoker','yes':'Smoker','smoker':'Smoker','smokes':'Smoker',
    'n':'Non-Smoker','no':'Non-Smoker','non-smoker':'Non-Smoker','nonsmoker':'Non-Smoker'
}
demo['smoking_status'] = demo['smoking_status'].map(smoking_map).fillna('Unknown')

demo['country']=demo['country'].fillna('Unknown')

"""1.4  Save patient_dim"""

patient_dim = demo[['patient_id','name','dob','age','gender','weight_kg','height_cm','bmi','smoking_status','enrollment_date','country','contact_number']]
patient_dim.to_csv("patient_dim.csv", index=False)

"""**2. LABS: normalize lab rows**"""

lab_cols = ["lab_id","patient_id","visit_date_x","test_name","value","unit","notes"]
labs = df[lab_cols].dropna(subset=['lab_id']).copy()  # keep real lab rows

labs['visit_date_x'] = pd.to_datetime(labs['visit_date_x'], errors='coerce')
labs['test_name'] = labs['test_name'].fillna('Unknown Test').str.strip()
labs['value'] = pd.to_numeric(labs['value'], errors='coerce')

labs.to_csv("labs_clean.csv", index=False)

"""**3. ADVERSE EVENTS**"""

ae_cols = ["ae_id","patient_id","event_date","event_type","severity","related_to_drug","description"]
ae = df[ae_cols].dropna(subset=['ae_id']).copy()

ae['event_date'] = pd.to_datetime(ae['event_date'], errors='coerce')
ae['event_type'] = ae['event_type'].fillna('Unknown')
ae['severity'] = ae['severity'].fillna('Unknown')
ae['related_to_drug'] = ae['related_to_drug'].fillna('Unknown')

ae.to_csv("ae_clean.csv", index=False)

"""**4. OUTCOMES**"""

out_cols = ["outcome_id","patient_id","visit_date_y","outcome","score","censor_flag","dropout_reason"]
out = df[out_cols].dropna(subset=['outcome_id']).copy()

out['visit_date_y'] = pd.to_datetime(out['visit_date_y'], errors='coerce')
out['score'] = pd.to_numeric(out['score'], errors='coerce')
out['score'] = out['score'].fillna(out['score'].median())
out['outcome'] = out['outcome'].fillna('Unknown')
out['dropout_reason'] = out['dropout_reason'].fillna('None')

out['censor_flag'] = (
    out['censor_flag']
    .replace({'Y': 1, 'N': 0, 'Yes': 1, 'No': 0})
)

out['censor_flag'] = pd.to_numeric(out['censor_flag'], errors='coerce').fillna(0).astype(int)

out.to_csv("outcomes_clean.csv", index=False)

"""*INCONSISTENCY CHECKS*"""

# Labs before enrollment
labs = labs.merge(
    patient_dim[['patient_id','enrollment_date']],
    on='patient_id', how='left'
)
labs['lab_date_issue'] = labs['visit_date_x'] < labs['enrollment_date']
labs['duplicate_lab'] = labs.duplicated(['patient_id','visit_date_x','test_name'])

# AE before enrollment
ae = ae.merge(
    patient_dim[['patient_id','enrollment_date']],
    on='patient_id', how='left'
)
ae['ae_date_issue'] = ae['event_date'] < ae['enrollment_date']
ae['duplicate_ae'] = ae.duplicated(['patient_id','event_date','event_type'])

ae['logic_issue_severe_not_related'] = (
    (ae['severity'].str.lower() == 'severe') &
    (ae['related_to_drug'].str.lower() == 'no')
)

# Outcome before enrollment
out = out.merge(
    patient_dim[['patient_id','enrollment_date']],
    on='patient_id', how='left'
)
out['outcome_date_issue'] = out['visit_date_y'] < out['enrollment_date']

out['logic_issue_completed_dropout'] = (
    (out['outcome'].str.lower() == 'completed') &
    (out['dropout_reason'] != 'None')
)

"""#Patient-Level Feature Engineering

AE counts, severity flags
"""

ae_counts = ae.groupby('patient_id').agg(
    total_ae=('ae_id','count'),
    severe_ae=('severity', lambda s: (s.str.lower()=='severe').sum())
).reset_index()

"""lab stats per patient (count, last value for a target test, mean)"""

lab_stats = labs.groupby('patient_id').agg(
    total_lab_tests=('lab_id','count'),
    lab_value_mean=('value','mean'),
    lab_value_std=('value','std')
).reset_index()

"""outcome latest"""

out_latest = out.sort_values(['patient_id','visit_date_y']).groupby('patient_id').last().reset_index()
out_latest = out_latest[['patient_id','outcome','score','visit_date_y','censor_flag','dropout_reason']]

quality_report = {
    "total_patients": patient_dim['patient_id'].nunique(),
    "unknown_gender_pct": (patient_dim['gender']=='Unknown').mean(),
    "unknown_smoking_pct": (patient_dim['smoking_status']=='Unknown').mean(),
    "lab_date_issue_pct": labs['lab_date_issue'].mean(),
    "ae_date_issue_pct": ae['ae_date_issue'].mean(),
    "outcome_date_issue_pct": out['outcome_date_issue'].mean(),
    "duplicate_lab_pct": labs['duplicate_lab'].mean(),
    "duplicate_ae_pct": ae['duplicate_ae'].mean(),
    "logic_issue_severe_ae_pct": ae['logic_issue_severe_not_related'].mean(),
    "logic_issue_completed_dropout_pct": out['logic_issue_completed_dropout'].mean()
}

pd.DataFrame([quality_report]).to_csv("data_quality_report.csv", index=False)
print(quality_report)

"""Merge all into master"""

master = patient_dim.merge(ae_counts, on='patient_id', how='left') \
                    .merge(lab_stats, on='patient_id', how='left') \
                    .merge(out_latest, on='patient_id', how='left')

KNOWN_DATE_FORMATS = [
    '%d/%m/%Y',          # 01/01/2023
    '%Y-%m-%d',          # 2023-01-01
    '%b %d, %Y',         # Jan 01, 2023
    '%d-%b-%Y',          # 01-Jan-2023
    '%Y/%m/%d',          # 2023/01/01
    '%B %d %Y',          # January 01 2023
    '%m/%d/%Y',          # 01/01/2023 (for month-first as a fallback)
    '%Y-%m-%dT%H:%M:%S', # ISO 8601 with time
    '%Y-%m-%dT%H:%M:%S.%f' # ISO 8601 with microseconds
]

def parse_date_robust(date_str):
    if pd.isna(date_str):
        return pd.NaT
    for fmt in KNOWN_DATE_FORMATS:
        try:
            parsed_date = pd.to_datetime(date_str, format=fmt, errors='coerce')
            if pd.notna(parsed_date):
                return parsed_date
        except (ValueError, TypeError):
            # Continue to the next format if parsing fails for any reason
            continue
    return pd.NaT

print("Defined the 'parse_date_robust' function.")

"""fill NA numeric zeros"""

for c in ['total_ae','severe_ae','total_lab_tests','lab_value_mean','lab_value_std','score']:
    if c in master.columns:
        master[c].fillna(0, inplace=True)
master['outcome'] = master['outcome'].fillna('Unknown')
master['time_to_outcome'] = (pd.to_datetime(master['visit_date_y'], format='mixed', dayfirst=True) - pd.to_datetime(master['enrollment_date'], format='mixed', dayfirst=True)).dt.days
master['time_to_outcome'] = master['time_to_outcome'].fillna(-1).astype(int)

"""engineered flags"""

master['dropout_flag'] = master['dropout_reason'].apply(lambda x: 0 if (pd.isna(x) or x=='None' or x=='') else 1)
master['high_risk'] = ((master['bmi'] >= 30) | (master['age'] >= 65) | (master['severe_ae']>0)).astype(int)

"""FINAL POST-MERGE CONSISTENCY FIX"""

# Numeric imputation (clinical-safe)
num_cols = ['weight_kg','height_cm','bmi']
for c in num_cols:
    if c in master.columns:
        master[c] = master[c].fillna(master[c].median())

# Gender standardization (FINAL safety)
master['gender'] = (
    master['gender']
    .str.lower()
    .map({'m':'Male','male':'Male','f':'Female','female':'Female'})
    .fillna('Unknown')
)

# Contact number
master['contact_number'] = master['contact_number'].fillna('Unknown')

# DOB
master['dob'] = master['dob'].fillna(master['dob'].median())

# Smoking normalization
master['smoking_status'] = (
    master['smoking_status']
    .str.lower()
    .map({
        'y':'Smoker','yes':'Smoker','smoker':'Smoker',
        'n':'Non-Smoker','no':'Non-Smoker','non-smoker':'Non-Smoker'
    })
    .fillna('Unknown')
)

# ---- Outcome-related fields
master['outcome'] = master['outcome'].fillna('Ongoing')

# if visit_date missing â†’ patient still ongoing
master['censor_flag'] = master['censor_flag'].fillna(1).astype(int)

# dropout reason
master['dropout_reason'] = master['dropout_reason'].fillna('None')

# ---- Time to outcome
master['time_to_outcome'] = master['time_to_outcome'].fillna(-1).astype(int)

# ---- Final data quality checks
assert master['patient_id'].isna().sum() == 0, "Patient ID NULLs exist!"
assert master['age'].isna().sum() == 0, "Age NULLs exist!"

print("Post-merge null handling completed")

"""**Reasoning**:
I will apply the `parse_date_robust` function to the 'enrollment_date' column of the `master` DataFrame to convert its entries into a consistent datetime format.


"""

master['enrollment_date'] = master['enrollment_date'].apply(parse_date_robust)
print("Applied `parse_date_robust` to 'enrollment_date' column.")

"""**final cleaned master**"""

master.to_csv("clean_master.csv", index=False)
print("Saved: patient_dim.csv, labs_clean.csv, ae_clean.csv, outcomes_clean.csv, clean_master.csv")

master.head(20)

master['enrollment_date'].astype(str).value_counts().head(30)

# Count missing values per column
missing_counts = master.isnull().sum()

# Keep only columns with missing values
missing_counts = missing_counts[missing_counts > 0]

# Bar chart
plt.figure(figsize=(10, 5))
missing_counts.plot(kind='bar')

plt.title('Missing Values per Column')
plt.xlabel('Columns')
plt.ylabel('Number of Missing Values')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""#DATA QUALITY REPORT (POST-CLEANING)"""

quality_report = pd.DataFrame({
    "metric": [
        "total_patients",
        "missing_dob_pct",
        "missing_gender_pct",
        "missing_lab_value_pct",
        "patients_with_no_outcome"
    ],
    "value": [
        master['patient_id'].nunique(),
        master['dob'].isna().mean(),
        (master['gender'] == 'Unknown').mean(),
        labs['value'].isna().mean(),
        (master['outcome'] == 'Unknown').mean()
    ]
})

quality_report.to_csv("data_quality_report.csv", index=False)

print(quality_report)